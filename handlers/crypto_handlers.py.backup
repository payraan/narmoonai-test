from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from services.coinstats_service import coinstats_service
from services.direct_api_service import direct_api_service
from services.holderscan_service import holderscan_service
from utils.crypto_formatter import (
    format_market_overview, format_error_message,
    format_token_info, format_trending_tokens, format_holders_info
)
from config.constants import (
    CRYPTO_MENU, DEX_MENU, COIN_MENU, DEX_SUBMENU, COIN_SUBMENU,
    MAIN_MENU
)
from database.operations import check_subscription, check_user_api_limit, log_api_request
import asyncio

async def crypto_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø±Ù…Ø²Ø§Ø±Ø² Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡"""
    query = update.callback_query
    if query:
        await query.answer()
        await query.edit_message_text("â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¨Ø§Ø²Ø§Ø±...")

    try:
        # Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø² APIÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
        btc_dominance_data = coinstats_service.get_btc_dominance()
        fear_greed_data = coinstats_service.get_fear_and_greed()
        global_data = direct_api_service.coingecko_global()
        
        # ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ù¾ÛŒØ§Ù…
        message = "ğŸª™ **Ù…Ù†ÙˆÛŒ Ø±Ù…Ø²Ø§Ø±Ø²**\n\n"
        
        # Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ Ø¨ÛŒØªÚ©ÙˆÛŒÙ†
        if not btc_dominance_data.get("error"):
            btc_dom = btc_dominance_data.get("btcDominance", 0)
            message += f"â‚¿ **Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ Ø¨ÛŒØªÚ©ÙˆÛŒÙ†:** {btc_dom:.2f}%\n"
        
        # Ø´Ø§Ø®Øµ ØªØ±Ø³ Ùˆ Ø·Ù…Ø¹
        if not fear_greed_data.get("error"):
            fear_greed = fear_greed_data.get("value", 0)
            fear_greed_text = fear_greed_data.get("valueClassification", "Ù†Ø§Ù…Ø´Ø®Øµ")
            message += f"ğŸ˜± **Ø´Ø§Ø®Øµ ØªØ±Ø³ Ùˆ Ø·Ù…Ø¹:** {fear_greed} ({fear_greed_text})\n"
        
        # Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ Ø¨Ø§Ø²Ø§Ø±
        if not global_data.get("error") and "data" in global_data:
            data = global_data["data"]
            total_market_cap = data.get("total_market_cap", {}).get("usd", 0)
            total_volume = data.get("total_volume", {}).get("usd", 0)
            market_cap_change = data.get("market_cap_change_percentage_24h_usd", 0)
            
            message += f"ğŸ“Š **Ú©Ù„ Ø¨Ø§Ø²Ø§Ø±:** ${total_market_cap:,.0f}\n"
            message += f"ğŸ“ˆ **Ø­Ø¬Ù… 24Ø³Ø§Ø¹ØªÙ‡:** ${total_volume:,.0f}\n"
            message += f"ğŸ“‰ **ØªØºÛŒÛŒØ± 24Ø³Ø§Ø¹ØªÙ‡:** {market_cap_change:+.2f}%\n"
        
        message += "\nğŸ”¹ Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
        
        # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù†Ùˆ
        keyboard = [
            [InlineKeyboardButton("ğŸ”„ Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ø¯Ú©Ø³", callback_data="narmoon_dex")],
            [InlineKeyboardButton("ğŸ’° Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ú©ÙˆÛŒÙ†", callback_data="narmoon_coin")],
            [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="main_menu")]
        ]

        if query:
            await query.edit_message_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )

    except Exception as e:
        print(f"Error in crypto_menu: {e}")
        error_message = "ğŸª™ **Ù…Ù†ÙˆÛŒ Ø±Ù…Ø²Ø§Ø±Ø²**\n\nÙ„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
        keyboard = [
            [InlineKeyboardButton("ğŸ”„ Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ø¯Ú©Ø³", callback_data="narmoon_dex")],
            [InlineKeyboardButton("ğŸ’° Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ú©ÙˆÛŒÙ†", callback_data="narmoon_coin")],
            [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="main_menu")]
        ]

        if query:
            await query.edit_message_text(
                error_message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                error_message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )

    return CRYPTO_MENU

async def dex_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ù†ÙˆÛŒ Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ø¯Ú©Ø³"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    dex_options = {
        'token_info': 'ğŸ” Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙˆÚ©Ù†',
        'trending_tokens': 'ğŸ”¥ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯', 
        'recently_updated': 'ğŸ”„ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡',
        'boosted_tokens': 'ğŸš€ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªÙ‚ÙˆÛŒØªâ€ŒØ´Ø¯Ù‡',
        'token_snipers': 'ğŸ¯ Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±Ù‡Ø§ÛŒ ØªÙˆÚ©Ù†',
        'token_holders': 'ğŸ‘¥ Ø¨Ø±Ø±Ø³ÛŒ Ù‡ÙˆÙ„Ø¯Ø±Ù‡Ø§ÛŒ ØªÙˆÚ©Ù†'
    }

    keyboard = []
    for key, label in dex_options.items():
        # Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù†ÛŒØ§Ø²Ù…Ù†Ø¯ Ø¢Ø¯Ø±Ø³ ØªÙˆÚ©Ù†
        input_required = key in ['token_info', 'token_snipers', 'token_holders']
        
        if not has_premium and input_required:
            label = f"ğŸ”’ {label}"
        
        keyboard.append([InlineKeyboardButton(label, callback_data=f"dex_{key}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="crypto")])

    await query.edit_message_text(
        "ğŸ”„ **Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ø¯Ú©Ø³**\n\n"
        "ØªØ­Ù„ÛŒÙ„ ØªØ®ØµØµÛŒ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ DEX Ø³ÙˆÙ„Ø§Ù†Ø§\n\n"
        "Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

    return DEX_MENU

async def coin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ù†ÙˆÛŒ Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ú©ÙˆÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    coin_options = {
        'general_search': 'ğŸ” Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¹Ù…ÙˆÙ…ÛŒ',
        'trending_coins': 'ğŸ”¥ Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯',
        'global_stats': 'ğŸŒ Ø¢Ù…Ø§Ø± Ø¬Ù‡Ø§Ù†ÛŒ Ú©Ø±ÛŒÙ¾ØªÙˆ',
        'defi_stats': 'ğŸ¦ Ø¢Ù…Ø§Ø± DeFi',
        'companies_treasury': 'ğŸ¢ Ø°Ø®Ø§ÛŒØ± Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§'
    }

    keyboard = []
    for key, label in coin_options.items():
        free_features = ['general_search', 'trending_coins', 'global_stats']
        if not has_premium and key not in free_features:
            label = f"ğŸ”’ {label}"
        
        keyboard.append([InlineKeyboardButton(label, callback_data=f"coin_{key}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="crypto")])

    await query.edit_message_text(
        "ğŸ’° **Ù†Ø§Ø±Ù…ÙˆÙˆÙ† Ú©ÙˆÛŒÙ†**\n\n"
        "ØªØ­Ù„ÛŒÙ„ ØªØ®ØµØµÛŒ Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§ÛŒ Ù…Ø¹ØªØ¨Ø± Ùˆ Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…ØªÙ…Ø±Ú©Ø²\n\n"
        "Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

    return COIN_MENU

async def handle_dex_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù†ÙˆÛŒ Ø¯Ú©Ø³"""
    query = update.callback_query
    await query.answer()

    option = query.data.replace("dex_", "")
    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ
    premium_required = option in ['token_info', 'token_snipers', 'token_holders']
    if not has_premium and premium_required:
        await query.answer("âš ï¸ Ø§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú© Ø¯Ø§Ø±Ø¯", show_alert=True)
        return DEX_MENU

    # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª API
    if not check_user_api_limit(user_id, has_premium):
        await query.edit_message_text(
            "âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_dex")
            ]])
        )
        return DEX_MENU

    await query.edit_message_text("â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª...")

    try:
        log_api_request(user_id, f"dex_{option}")

        if option == 'token_info':
            context.user_data['waiting_for'] = 'token_address'
            context.user_data['action_type'] = 'token_info'
            
            await query.edit_message_text(
                "ğŸ” **Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙˆÚ©Ù†**\n\n"
                "Ù„Ø·ÙØ§Ù‹ Ø¢Ø¯Ø±Ø³ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ ØªÙˆÚ©Ù† Ø³ÙˆÙ„Ø§Ù†Ø§ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n\n"
                "Ù…Ø«Ø§Ù„: `7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr`\n\n"
                "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU

        elif option == 'trending_tokens':
            # Ù†Ù…Ø§ÛŒØ´ Ø²ÛŒØ±Ù…Ù†ÙˆÛŒ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯
            keyboard = [
                [InlineKeyboardButton("ğŸŒ Ù‡Ù…Ù‡ Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§", callback_data="trending_all_networks")],
                [InlineKeyboardButton("ğŸ”— Ø³ÙˆÙ„Ø§Ù†Ø§ ÙÙ‚Ø·", callback_data="trending_solana_only")],
                [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_dex")]
            ]
            
            await query.edit_message_text(
                "ğŸ”¥ **ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯**\n\n"
                "Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
            return DEX_MENU

        elif option == 'recently_updated':
            data = direct_api_service.geckoterminal_recently_updated()
            message = format_recently_updated_tokens(data)
            
        elif option == 'boosted_tokens':
            data = direct_api_service.dexscreener_boosted_tokens()
            message = format_boosted_tokens(data)
            
        elif option == 'token_snipers':
            context.user_data['waiting_for'] = 'pair_address'
            context.user_data['action_type'] = 'token_snipers'
            
            await query.edit_message_text(
                "ğŸ¯ **Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±Ù‡Ø§ÛŒ ØªÙˆÚ©Ù†**\n\n"
                "Ù„Ø·ÙØ§Ù‹ Ø¢Ø¯Ø±Ø³ Ø¬ÙØª (Pair Address) Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n\n"
                "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU
            
        elif option == 'token_holders':
            context.user_data['waiting_for'] = 'token_contract'
            context.user_data['action_type'] = 'token_holders'
            
            await query.edit_message_text(
                "ğŸ‘¥ **Ø¨Ø±Ø±Ø³ÛŒ Ù‡ÙˆÙ„Ø¯Ø±Ù‡Ø§ÛŒ ØªÙˆÚ©Ù†**\n\n"
                "Ù„Ø·ÙØ§Ù‹ Ø¢Ø¯Ø±Ø³ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ ØªÙˆÚ©Ù† Ø³ÙˆÙ„Ø§Ù†Ø§ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n\n"
                "Ù…Ø«Ø§Ù„: `7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr`\n\n"
                "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU

        else:
            message = "ğŸš§ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡ Ø§Ø³Øª..."

        # Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_dex")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_dex_option: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_dex")
            ]])
        )

    return DEX_MENU

async def handle_coin_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù†ÙˆÛŒ Ú©ÙˆÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    option = query.data.replace("coin_", "")
    user_id = update.effective_user.id
    has_premium = check_subscription(user_id)

    # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ
    free_features = ['general_search', 'trending_coins', 'global_stats']
    if not has_premium and option not in free_features:
        await query.answer("âš ï¸ Ø§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú© Ø¯Ø§Ø±Ø¯", show_alert=True)
        return COIN_MENU

    # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª API
    if not check_user_api_limit(user_id, has_premium):
        await query.edit_message_text(
            "âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_coin")
            ]])
        )
        return COIN_MENU

    await query.edit_message_text("â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª...")

    try:
        log_api_request(user_id, f"coin_{option}")

        if option == 'general_search':
            context.user_data['waiting_for'] = 'search_query'
            context.user_data['action_type'] = 'general_search'
            
            await query.edit_message_text(
                "ğŸ” **Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¹Ù…ÙˆÙ…ÛŒ**\n\n"
                "Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… ÛŒØ§ Ù†Ù…Ø§Ø¯ Ú©ÙˆÛŒÙ† Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n\n"
                "Ù…Ø«Ø§Ù„: Bitcoin ÛŒØ§ BTC\n\n"
                "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ: /cancel",
                parse_mode='Markdown'
            )
            return DEX_SUBMENU  # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‡Ù…Ø§Ù† state

        elif option == 'trending_coins':
            data = direct_api_service.coingecko_trending()
            message = format_trending_coins(data)
            
        elif option == 'global_stats':
            data = direct_api_service.coingecko_global()
            message = format_global_stats(data)
            
        elif option == 'defi_stats':
            data = direct_api_service.coingecko_defi()
            message = format_defi_stats(data)
            
        elif option == 'companies_treasury':
            # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©ÙˆÛŒÙ†
            keyboard = [
                [InlineKeyboardButton("â‚¿ Bitcoin", callback_data="treasury_bitcoin")],
                [InlineKeyboardButton("Î Ethereum", callback_data="treasury_ethereum")],
                [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_coin")]
            ]
            
            await query.edit_message_text(
                "ğŸ¢ **Ø°Ø®Ø§ÛŒØ± Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§**\n\n"
                "Ù„Ø·ÙØ§Ù‹ Ú©ÙˆÛŒÙ† Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
            return COIN_MENU

        else:
            message = "ğŸš§ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡ Ø§Ø³Øª..."

        # Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_coin")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_coin_option: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_coin")
            ]])
        )

    return COIN_MENU

async def handle_trending_options(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯"""
    query = update.callback_query
    await query.answer()

    option = query.data
    await query.edit_message_text("â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯...")

    try:
        if option == "trending_all_networks":
            data = direct_api_service.geckoterminal_trending_all()
            message = format_trending_all_networks(data)
            
        elif option == "trending_solana_only":
            # ØªØ±Ú©ÛŒØ¨ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø§Ø² GeckoTerminal Ùˆ Moralis
            combined_data = await direct_api_service.get_combined_solana_trending()
            message = format_combined_solana_trending(combined_data)

        # Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¯Ú©Ø³", callback_data="narmoon_dex")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_trending_options: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_dex")
            ]])
        )

    return DEX_MENU

async def handle_treasury_options(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ø°Ø®Ø§ÛŒØ± Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§"""
    query = update.callback_query
    await query.answer()

    coin_id = query.data.replace("treasury_", "")
    await query.edit_message_text("â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø°Ø®Ø§ÛŒØ±...")

    try:
        data = direct_api_service.coingecko_companies_treasury(coin_id)
        message = format_companies_treasury(data, coin_id)

        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ú©ÙˆÛŒÙ†", callback_data="narmoon_coin")]]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

    except Exception as e:
        print(f"Error in handle_treasury_options: {e}")
        await query.edit_message_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="narmoon_coin")
            ]])
        )

    return COIN_MENU

async def process_user_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±"""
    waiting_for = context.user_data.get('waiting_for')
    action_type = context.user_data.get('action_type')
    
    if not waiting_for or not action_type:
        return DEX_SUBMENU

    user_input = update.message.text.strip()
    await update.message.reply_text("ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...")

    try:
        if action_type == 'token_info':
            # Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙˆÚ©Ù† Ø§Ø² GeckoTerminal
            data = direct_api_service.geckoterminal_token_info("solana", user_input)
            message = format_token_info(data)
            
        elif action_type == 'token_snipers':
            # Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±Ù‡Ø§ÛŒ ØªÙˆÚ©Ù† Ø§Ø² Moralis
            data = direct_api_service.moralis_snipers(user_input)
            message = format_snipers_info(data)
            
        elif action_type == 'token_holders':
            # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù‡ÙˆÙ„Ø¯Ø±Ù‡Ø§ Ø§Ø² HolderScan
            holders_data = holderscan_service.token_holders(user_input, limit=20)
            stats_data = holderscan_service.token_stats(user_input)
            deltas_data = holderscan_service.holder_deltas(user_input)
            
            message = format_holders_info(holders_data, stats_data, deltas_data)
            
        elif action_type == 'general_search':
            # Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¹Ù…ÙˆÙ…ÛŒ Ø§Ø² CoinGecko
            data = direct_api_service.coingecko_search(user_input)
            message = format_search_results(data)

        else:
            message = "âŒ Ù†ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†Ø´Ø¯."

        # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª
        if action_type in ['token_info', 'token_snipers', 'token_holders']:
            back_button = "narmoon_dex"
        else:
            back_button = "narmoon_coin"
            
        keyboard = [
            [InlineKeyboardButton(f"ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=back_button)]
        ]

        await update.message.reply_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

        # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª
        context.user_data.clear()
        return CRYPTO_MENU

    except Exception as e:
        print(f"Error in process_user_input: {e}")
        await update.message.reply_text(
            format_error_message("general"),
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="crypto")
            ]])
        )
        context.user_data.clear()
        return CRYPTO_MENU

# === Helper Functions for Formatting ===

def format_recently_updated_tokens(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡"""
    if data.get("error") or "data" not in data:
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡."
    
    message = "ğŸ”„ **ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡**\n\n"
    
    tokens = data["data"].get("tokens", [])[:10]
    for i, token in enumerate(tokens, 1):
        attributes = token.get("attributes", {})
        name = attributes.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
        symbol = attributes.get("symbol", "???")
        address = attributes.get("address", "")[:8] + "..."
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   ğŸ“ {address}\n\n"
    
    return message

def format_boosted_tokens(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªÙ‚ÙˆÛŒØªâ€ŒØ´Ø¯Ù‡"""
    if not isinstance(data, list) or not data:
        return "âŒ Ù‡ÛŒÚ† ØªÙˆÚ©Ù† ØªÙ‚ÙˆÛŒØªâ€ŒØ´Ø¯Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯."
    
    message = "ğŸš€ **ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªÙ‚ÙˆÛŒØªâ€ŒØ´Ø¯Ù‡**\n\n"
    
    tokens = data[:10]
    for i, token in enumerate(tokens, 1):
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ø§Ù… ØªÙˆÚ©Ù† Ø§Ø² URL ÛŒØ§ Ø¢Ø¯Ø±Ø³
        token_address = token.get("tokenAddress", "")
        description = token.get("description", "")
        
        # ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ø§Ù… Ø§Ø² description
        name = "Ù†Ø§Ù…Ø´Ø®Øµ"
        symbol = "???"
        
        if description:
            # Ø¬Ø³ØªØ¬Ùˆ Ø¨Ø±Ø§ÛŒ Ù†Ø§Ù… Ø¯Ø± ØªÙˆØ¶ÛŒØ­Ø§Øª
            desc_words = description.split()
            for word in desc_words:
                if word.startswith("$") and len(word) > 1:
                    symbol = word[1:]  # Ø­Ø°Ù $
                    name = word
                    break
        
        if token_address:
            symbol = token_address[:6] + "..."
        
        message += f"{i}. **{name}** ({symbol})\n"
        if description:
            # Ù†Ù…Ø§ÛŒØ´ Ø¨Ø®Ø´ Ú©ÙˆØªØ§Ù‡ÛŒ Ø§Ø² ØªÙˆØ¶ÛŒØ­Ø§Øª
            short_desc = description[:50] + "..." if len(description) > 50 else description
            message += f"   ğŸ“ {short_desc}\n"
        message += "\n"
    
    return message

def format_trending_coins(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯"""
    if data.get("error") or "coins" not in data:
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯."
    
    message = "ğŸ”¥ **Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯**\n\n"
    
    coins = data["coins"][:10]
    for i, coin_data in enumerate(coins, 1):
        item = coin_data.get("item", {})
        name = item.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
        symbol = item.get("symbol", "???").upper()
        market_cap_rank = item.get("market_cap_rank", "N/A")
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   ğŸ“Š Ø±Ù†Ú©: #{market_cap_rank}\n\n"
    
    return message

def format_global_stats(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø¢Ù…Ø§Ø± Ø¬Ù‡Ø§Ù†ÛŒ"""
    if data.get("error") or "data" not in data:
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¬Ù‡Ø§Ù†ÛŒ."
    
    stats = data["data"]
    message = "ğŸŒ **Ø¢Ù…Ø§Ø± Ø¬Ù‡Ø§Ù†ÛŒ Ú©Ø±ÛŒÙ¾ØªÙˆ**\n\n"
    
    # Ú©Ù„ Ø¨Ø§Ø²Ø§Ø±
    total_market_cap = stats.get("total_market_cap", {}).get("usd", 0)
    message += f"ğŸ’° **Ú©Ù„ Ø¨Ø§Ø²Ø§Ø±:** ${total_market_cap:,.0f}\n"
    
    # Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª
    total_volume = stats.get("total_volume", {}).get("usd", 0)
    message += f"ğŸ“ˆ **Ø­Ø¬Ù… 24Ø³Ø§Ø¹ØªÙ‡:** ${total_volume:,.0f}\n"
    
    # Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³
    btc_dominance = stats.get("market_cap_percentage", {}).get("btc", 0)
    eth_dominance = stats.get("market_cap_percentage", {}).get("eth", 0)
    message += f"â‚¿ **Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ BTC:** {btc_dominance:.1f}%\n"
    message += f"Î **Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ ETH:** {eth_dominance:.1f}%\n"
    
    # ØªØ¹Ø¯Ø§Ø¯ Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§
    active_cryptocurrencies = stats.get("active_cryptocurrencies", 0)
    message += f"ğŸª™ **Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„:** {active_cryptocurrencies:,}\n"
    
    # ØªØºÛŒÛŒØ± 24 Ø³Ø§Ø¹ØªÙ‡
    market_cap_change = stats.get("market_cap_change_percentage_24h_usd", 0)
    message += f"ğŸ“Š **ØªØºÛŒÛŒØ± 24Ø³Ø§Ø¹ØªÙ‡:** {market_cap_change:+.2f}%\n"
    
    return message

def format_defi_stats(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø¢Ù…Ø§Ø± DeFi"""
    if data.get("error") or "data" not in data:
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± DeFi."
    
    stats = data["data"]
    message = "ğŸ¦ **Ø¢Ù…Ø§Ø± DeFi**\n\n"
    
    # Ú©Ù„ Ø¨Ø§Ø²Ø§Ø± DeFi
    defi_market_cap = stats.get("defi_market_cap", 0)
    message += f"ğŸ’ **Ú©Ù„ Ø¨Ø§Ø²Ø§Ø± DeFi:** ${defi_market_cap:,.0f}\n"
    
    # Ø¯Ø±ØµØ¯ Ø§Ø² Ú©Ù„ Ø¨Ø§Ø²Ø§Ø±
    defi_dominance = stats.get("defi_to_eth_ratio", 0) * 100
    message += f"ğŸ“Š **Ø³Ù‡Ù… Ø§Ø² Ú©Ù„ Ø¨Ø§Ø²Ø§Ø±:** {defi_dominance:.2f}%\n"
    
    # Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª DeFi
    trading_volume = stats.get("trading_volume_24h", 0)
    message += f"ğŸ“ˆ **Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª 24Ø³Ø§Ø¹ØªÙ‡:** ${trading_volume:,.0f}\n"
    
    return message

def format_companies_treasury(data, coin_id):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø°Ø®Ø§ÛŒØ± Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§"""
    if data.get("error") or "companies" not in data:
        return f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø°Ø®Ø§ÛŒØ± {coin_id}."
    
    coin_name = "Bitcoin" if coin_id == "bitcoin" else "Ethereum"
    symbol = "BTC" if coin_id == "bitcoin" else "ETH"
    
    message = f"ğŸ¢ **Ø°Ø®Ø§ÛŒØ± {coin_name} Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§**\n\n"
    
    companies = data["companies"][:10]
    total_holdings = 0
    
    for i, company in enumerate(companies, 1):
        name = company.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
        holdings = company.get("total_holdings", 0)
        total_holdings += holdings
        
        message += f"{i}. **{name}**\n"
        message += f"   ğŸ’° {holdings:,.0f} {symbol}\n\n"
    
    message += f"ğŸ“Š **Ù…Ø¬Ù…ÙˆØ¹ Ø¯Ù‡ Ø´Ø±Ú©Øª Ø¨Ø±ØªØ±:** {total_holdings:,.0f} {symbol}\n"
    
    return message

def format_trending_all_networks(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯ Ù‡Ù…Ù‡ Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§"""
    if data.get("error") or "data" not in data:
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯."
    
    message = "ğŸŒ **ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯ Ù‡Ù…Ù‡ Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§**\n\n"
    
    pools = data["data"].get("pools", [])[:10]
    for i, pool in enumerate(pools, 1):
        attributes = pool.get("attributes", {})
        base_token = attributes.get("base_token", {})
        
        name = base_token.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
        symbol = base_token.get("symbol", "???")
        network = pool.get("relationships", {}).get("dex", {}).get("data", {}).get("id", "Ù†Ø§Ù…Ø´Ø®Øµ")
        price_change = attributes.get("price_change_percentage", {}).get("h24", 0)
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   ğŸŒ {network}\n"
        message += f"   ğŸ“ˆ ØªØºÛŒÛŒØ± 24Ø³: {price_change:+.2f}%\n\n"
    
    return message

def format_combined_solana_trending(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯ Ø³ÙˆÙ„Ø§Ù†Ø§ ØªØ±Ú©ÛŒØ¨ÛŒ"""
    if not data.get("success"):
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯ Ø³ÙˆÙ„Ø§Ù†Ø§."
    
    message = "ğŸ”— **ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ ØªØ±Ù†Ø¯ Ø³ÙˆÙ„Ø§Ù†Ø§**\n\n"
    
    tokens = data.get("combined_tokens", [])[:15]
    for i, token in enumerate(tokens, 1):
        name = token.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
        symbol = token.get("symbol", "???")
        source = token.get("source", "Ù†Ø§Ù…Ø´Ø®Øµ")
        
        # ØªØ¨Ø¯ÛŒÙ„ Ø§ÛŒÙ…Ù† price_change Ø¨Ù‡ float
        try:
            price_change = float(token.get("price_change_24h", 0))
        except (ValueError, TypeError):
            price_change = 0.0
        
        message += f"{i}. **{name}** ({symbol})\n"
        message += f"   ğŸ“Š Ù…Ù†Ø¨Ø¹: {source}\n"
        message += f"   ğŸ“ˆ ØªØºÛŒÛŒØ± 24Ø³: {price_change:+.2f}%\n\n"
    
    message += f"ğŸ“ˆ **Ù…Ø¬Ù…ÙˆØ¹:** {len(tokens)} ØªÙˆÚ©Ù† Ø§Ø² GeckoTerminal\n"
    
    return message

def format_search_results(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬ Ø¬Ø³ØªØ¬Ùˆ"""
    if data.get("error"):
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬Ùˆ."
    
    message = "ğŸ” **Ù†ØªØ§ÛŒØ¬ Ø¬Ø³ØªØ¬Ùˆ**\n\n"
    
    # Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§
    coins = data.get("coins", [])[:5]
    if coins:
        message += "**ğŸ’° Ú©ÙˆÛŒÙ†â€ŒÙ‡Ø§:**\n"
        for coin in coins:
            name = coin.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
            symbol = coin.get("symbol", "???")
            market_cap_rank = coin.get("market_cap_rank")
            
            message += f"â€¢ **{name}** ({symbol})"
            if market_cap_rank:
                message += f" - Ø±Ù†Ú© #{market_cap_rank}"
            message += "\n"
        message += "\n"
    
    # ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§
    exchanges = data.get("exchanges", [])[:3]
    if exchanges:
        message += "**ğŸª ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§:**\n"
        for exchange in exchanges:
            name = exchange.get("name", "Ù†Ø§Ù…Ø´Ø®Øµ")
            message += f"â€¢ {name}\n"
        message += "\n"
    
    if not coins and not exchanges:
        message += "Ù‡ÛŒÚ† Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯."
    
    return message

def format_snipers_info(data):
    """ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±Ù‡Ø§"""
    if data.get("error"):
        return "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±Ù‡Ø§."
    
    message = "ğŸ¯ **Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±Ù‡Ø§ÛŒ ØªÙˆÚ©Ù†**\n\n"
    
    if isinstance(data, list) and data:
        for i, sniper in enumerate(data[:10], 1):
            address = sniper.get("address", "Ù†Ø§Ù…Ø´Ø®Øµ")[:8] + "..."
            amount = sniper.get("amount", 0)
            
            message += f"{i}. **Ø¢Ø¯Ø±Ø³:** {address}\n"
            message += f"   ğŸ’° Ù…Ù‚Ø¯Ø§Ø±: {amount}\n\n"
    else:
        message += "Ù‡ÛŒÚ† Ø§Ø³Ù†Ø§ÛŒÙ¾Ø±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯."
    
    return message
